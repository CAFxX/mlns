require "set"
require 'logger'
logger = Logger.new(STDERR)

C=ARGV[0].to_i
raise "illegal C=#{C}" if C < 2

logger.info "Base cases..."
cs=[[0]]
(C-1).times {
        cs0 = cs.map{|c| c + [c.last] }
        cs1 = cs.map{|c| c + [c.last+1] }
        cs = cs0 + cs1
}
#puts cs.length
#puts cs.inspect

logger.info "Permutations..."
pcs=Set.new
cs.each{|c| pcs.merge(c.permutation) }

def sort_indexes(a)
	a.each_with_index.to_a.sort_by{|x| x}.map(&:last)
end

def find_all_indexes(a, i)
	i.map{|x| a.each_index.select{|y| a[y] == a[x] } }
end

def comparison_results(a)
        r = []
        (0...a.length).each{|i|
                (i+1...a.length).each{|j|
                        r << (a[i]<a[j]?1:0)
                }
        }
        r
end

logger.info "Mapping..."
m={}
pcs.each{|x|
        r = comparison_results(x)
        s = sort_indexes(x)
		a = find_all_indexes(x, s)
		if !m.key?(r)
			m[r] = a
			next
		end
		ba = m[r]
		nba = ba.map.with_index{|c, i| c.intersection(a[i]) }
		if nba.any?(&:empty?)
			puts [x, r, s, a].inspect
			puts ba.inspect
			puts nba.inspect
        	raise "conflict" 
		end
        m[r] = nba
}
#puts m.inspect

logger.info "Generating code..."
puts "// minimal latency #{C}-sorter for B bits values"
puts "// generated by mlnsgen"
puts "// comparisons=#{(C*C-C)/2}, evals=#{pcs.length}, total cases=#{2**((C*C-C)/2)}, valid cases=#{m.length}, orderings=#{(1..C).reduce(1, :*)}"
puts "module nsorter_#{C} #("
puts "  parameter B = 64"
puts ") ("
puts C.times.map {|x| ["  input [B-1:0] in#{x}", "  output reg [B-1:0] out#{x}"] }.flatten.join(",\n")
puts ");"
k=0
(0...C).each{|i|
	(i+1...C).each{|j|
		puts "  wire c#{k} = in#{i} < in#{j};"
		k += 1
	}
}
puts "  always @(*) begin"
puts "    case ({#{(0...((C*C-C)/2)).to_a.map{|x| "c#{x}" }.join(",")}})"
m.keys.sort.each{|k| v=m[k]
	#puts "      #{k.length}'b#{k.join("")}: out = {#{v.map{|e| "in[#{e[0]}]" }.join(",") }};"
	puts "      #{k.length}'b#{k.join}: begin #{v.map.with_index{|e,i| "out#{i} = in#{e[0]}; "}.join}end"
}
#puts "      default: out = {#{C}{B{1'bx}}}; // #{2**((C*C-C)/2) - m.length} invalid cases" unless m.length == 2**((C*C-C)/2)
puts "      default: begin #{C.times.map {|x| "out#{x} = {B{1'bx}}; "}.join}end // #{2**((C*C-C)/2) - m.length} invalid cases" unless m.length == 2**((C*C-C)/2)
puts "    endcase"
puts "  end"
puts "endmodule"